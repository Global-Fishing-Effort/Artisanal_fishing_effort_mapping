---
title: "Data wrangling - Spatial measures 0.5 degrees"
author: "Gage Clawson (IMAS)"
date: '`r format(Sys.time(), "%m/%d/%Y")`'
output: 
  pdf_document: 
    number_sections: yes
    toc: true
    toc_depth: 4
editor_options: 
  chunk_output_type: console
---

# Summary

Prep spatial measures we use to inform our model at 0.5 degree resolution
 - distance to short, port
 - bathymetry (depth)
 - FAO regions
 - mesopelagic regions
 - ocean regions
 - distance to nearest seamount
 - days at sea to fishing hours data

```{r echo = FALSE}
# This chunk sets up default settings for all chunks below
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,fig.width = 7.5,fig.height = 5,dev = 'png',dpi=300)
```

```{r include=FALSE}
# Load all necessary packages
library(tidyverse)
library(sf)
library(glue)
library(rnaturalearth)
library(furrr)
library(countrycode)
library(terra)
library(data.table)
library(here)
library(furrr)
library(here)
library(janitor)
library(raster)
library(fasterize)

options(scipen = 20)

source(here("R/dir.R"))

data_directory <- rdsi_raw_dir

```

# Defining our global grid

```{r}
pixel_size <- 0.5

mollweide_projection <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"

# Read in data_grid, generated in data_wrangling.Rmd
# We will do spatial joining in Mollweide, for proper calculations
# Note that data grid still retains lat and lon columns, for joining with non-spatial tibbles
# For Mollweide, always wrap around dateline, then transform, then calculate areas at end

data_grid <- data.table::fread(here::here("data/model_features/global_grid.csv")) %>%
  st_as_sf(wkt = "geometry_wkt",
           crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs") %>%
              mutate(pixel_area_m2 = sf::st_area(geometry_wkt) %>%
                 units::drop_units())
```

# Bathymetry, distance from shore, and distance to port (static)

GFW has spatial static measures at 0.01x0.01 degree resolution for bathymetry, distance from shore, and distance to port, all in meters (m). Distance to port is the distance to the closest port as defined by [GFW's port database and algorithm](https://globalfishingwatch.org/datasets-and-code-anchorages/). For each of our `r pixel_size`x`r pixel_size` degree pixels, we will take the average value for these static measures.

```{r}

bathymetry_data <- rast(file.path(data_directory, "global_fishing_watch/bathymetry/bathymetry.tif")) 

bathymetry_rast <- aggregate(bathymetry_data, fact = 60, fun = "mean")

bathymetry <- bathymetry_rast %>%
  as.data.frame(., xy = TRUE) %>% 
  rename(lon = x, lat = y, elevation_m = bathymetry) %>%
  mutate(
    lat = floor(lat / pixel_size) * pixel_size,
    lon = floor(lon / pixel_size) * pixel_size
  ) %>%
  filter(elevation_m <= 0) %>%
   group_by(lon, lat) %>%
  summarize(elevation_m = mean(elevation_m, na.rm = TRUE), .groups = "drop")

# test <- bathymetry %>%
#   rast(., type = "xyz")
  
write.csv(bathymetry, file.path(data_directory, "global_fishing_watch/bathymetry/bathymetry_0.5.csv"), row.names = FALSE)

distance_from_port_data <- rast(file.path(data_directory, "global_fishing_watch/distance_from_port/distance-from-port-v1.tiff")) 

distance_from_port <- aggregate(distance_from_port_data, fact = 50, fun = "mean") %>%
  as.data.frame(., xy=TRUE) %>%
  rename(lon = x, lat = y, distance_from_port_m = `distance-from-port-v1`) %>%
    mutate(
    lat = floor(lat / pixel_size) * pixel_size,
    lon = floor(lon / pixel_size) * pixel_size
  ) %>%
   group_by(lon, lat) %>%
  summarize(distance_from_port_m = mean(distance_from_port_m, na.rm = TRUE), .groups = "drop")
  
write.csv(distance_from_port, file.path(data_directory, "global_fishing_watch/distance_from_port/distance_from_port_0.5.csv"), row.names = FALSE)

distance_from_shore_data <- rast(file.path(data_directory, "global_fishing_watch/distance_from_shore/distance-from-shore.tif")) 

distance_from_shore <- aggregate(distance_from_shore_data, fact = 50, fun = "mean") %>%
  as.data.frame(.,  xy = TRUE) %>%
    rename(lon = x, lat = y, distance_from_shore_m = `distance-from-shore`) %>%
      mutate(
    lat = floor(lat / pixel_size) * pixel_size,
    lon = floor(lon / pixel_size) * pixel_size
  ) %>%
   group_by(lon, lat) %>%
  summarize(distance_from_shore_m = mean(distance_from_shore_m, na.rm = TRUE), .groups = "drop")

  write.csv(distance_from_shore, file.path(data_directory, "global_fishing_watch/distance_from_shore/distance_from_shore_0.5.csv"), row.names = FALSE)


  # Read in cached spatial measures data, add data_grid info and make into sf
static_spatial_measures <- bathymetry %>%
  full_join(distance_from_port, by = c("lat", "lon")) %>%
  full_join(distance_from_shore, by = c("lat", "lon")) %>% 
  inner_join(data_grid, by = c("lat", "lon")) %>% 
    # For some nearshore areas, replace NA depth with 0
  mutate(elevation_m = ifelse(is.na(elevation_m),
                              0,
                              elevation_m))

static_spatial_measures %>%
  dplyr::select(-geometry_wkt) %>%
  data.table::fwrite(here::here("data/model_features/gfw_static_spatial_measures.csv"))

```

# Determine FAO region of each cell 
https://www.marineregions.org/gazetteer.php?p=details&id=22541

```{r}
## see if we can fill the missing fao_id pixels using different method 

fao <- st_read(file.path(rdsi_raw_dir, "fao/FAO_AREAS_CWP")) %>%
  filter(F_LEVEL == "MAJOR") %>%
  mutate(F_AREA = as.numeric(F_AREA))

# Check if CRS is different and transform if needed
if (st_crs(fao) != st_crs(data_grid)) {
  cat("\nTransforming FAO CRS to match data grid...\n")
  fao <- st_transform(fao, st_crs(data_grid))
}

# Save FAO major IDs
fao_major_ids <- fao %>% 
  st_drop_geometry() %>%
  distinct(fao_id = F_AREA, NAME_EN, OCEAN) %>%
  clean_names()

write.csv(fao_major_ids, here("data/model_features/fao/fao_major_ids.csv"), row.names = FALSE)

# Convert grid to raster
grid <- data_grid %>%
  st_drop_geometry() %>%
  dplyr::select(lon, lat, pixel_id) %>% 
  rast(., type = "xyz") 

# Rasterize FAO areas
fao_rast <- rast(fasterize::fasterize(fao, raster(grid), field = "F_AREA"))

# Count NA cells in FAO raster
na_count <- global(is.na(fao_rast), "sum")
cat("\nNumber of NA cells in FAO raster:", na_count$sum, "\n") # 80001

351*720 - 80001 # 172719; ok, this value SHOULD BE ~180k (the number of ocean cells, e.g. grid). However, it is lower than that. So we are missing ~8000 cells that should have FAO fishing area information. 

writeRaster(fao_rast, here("data/model_features/fao/fao_id_rast.tif"), overwrite = TRUE)

# Create lookup table
fao_lookup <- fao_rast %>%
  as.data.frame(xy = TRUE, na.rm = FALSE)

# Join with data_grid to get pixel_id and fao_id pairs
fao_lookup_fin <- fao_lookup %>%
  dplyr::select(lon = x, lat = y, fao_id = layer) %>%
  full_join(data_grid %>% st_drop_geometry(), by = c("lon", "lat")) %>% 
  filter(!is.na(pixel_id)) %>%
  dplyr::select(pixel_id, fao_id)

write.csv(fao_lookup_fin, here("data/model_features/fao/fao.csv"), row.names = FALSE)

# Analyze missing FAO IDs
missing_fao <- fao_lookup_fin %>%
  filter(is.na(fao_id))

cat("\nNumber of pixels with missing FAO ID:", nrow(missing_fao), "\n") # 7881

# Get the coordinates of missing pixels
missing_pixels <- data_grid %>%
  filter(pixel_id %in% missing_fao$pixel_id)

# Save missing pixels for visualization
st_write(missing_pixels, here("data/model_features/fao/missing_fao_pixels.shp"), delete_layer = TRUE)

# Create a simple plot of missing pixels
missing_coords <- missing_pixels %>%
  st_centroid() %>%
  st_coordinates() %>%
  as.data.frame()

# Save coordinates for plotting
write.csv(missing_coords, here("data/model_features/fao/missing_fao_coords.csv"), row.names = FALSE)

## we need to fill in any NA fao_id's with the nearest non-NA pixel_id's fao_id
library(zoo)
fao_lookup_fin <- fao_lookup_fin %>%
  arrange(pixel_id)

# Fill missing fao_id using nearest non-NA values. we will just use filling up or down for this, since we already know the pixel_ids are in order from where they are located. we assume that if the pixel id is close to it, then it will be in the same FAO id. Nearest neighbor would be better probably. 
fao_lookup_fin <- fao_lookup_fin %>%
  mutate(fao_id = na.locf(fao_id, na.rm = FALSE, fromLast = FALSE)) %>%  # Forward fill
  mutate(fao_id = na.locf(fao_id, na.rm = FALSE, fromLast = TRUE))       # Backward fill

# Check if there are still any NAs left
sum(is.na(fao_lookup_fin$fao_id)) 

write.csv(fao_lookup_fin, here("data/model_features/fao/fao_fixed.csv"), row.names = FALSE)

  check <-   read.csv(here("data/model_features/fao/fao_fixed.csv"))


```

# Determine mesopelagic region of each cell

Use Marine Region's [Mesopelagic ecoregions of the world's oceans](https://www.sciencedirect.com/science/article/pii/S0967063717301437?via%3Dihub#ack0005)

```{r}
meso <- st_read(glue("{data_directory}/marine_regions/mesopelagiczones/")) %>%
  clean_names() %>%
  rename(meso_id = provid)

meso_ids <- meso %>%
  st_drop_geometry() %>%
  dplyr::select(meso_id, meso_region = provname)


 grid <- data_grid %>%
  st_drop_geometry() %>%
  dplyr::select(lon, lat, pixel_id) %>% 
  rast(., type = "xyz") 
 
meso_rast <- rast(fasterize::fasterize(meso, raster(grid), field = "meso_id"))


writeRaster(meso_rast, here("data/model_features/mesopelagiczones/meso_id_rast.tif"), overwrite = TRUE)

# Count NA cells in FAO raster
na_count <- global(is.na(meso_rast), "sum")
cat("\nNumber of NA cells in FAO raster:", na_count$sum, "\n") # 97881; this is too many!! 


meso_lookup <- meso_rast %>%
  as.data.frame(xy = TRUE)


meso_lookup_id <- meso_lookup %>%
  dplyr::select(lon = x, lat = y, meso_id = layer) %>%
  full_join(data_grid) %>% 
    filter(!is.na(pixel_id)) %>%
  dplyr::select(pixel_id, meso_id)

cat("\nFAO lookup table dimensions:", dim(meso_lookup_id)[1], "rows,", dim(meso_lookup_id)[2], "columns\n") # ok good but many of these are NA... we need to fill these in


test <- meso_lookup_id %>%
  group_by(pixel_id) %>%
  summarise(n_distinct(meso_id)) # ok cool, seems to have worked?! 
  
write.csv(meso_lookup_id, here("data/model_features/mesopelagiczones/mesopelagiczones.csv"), row.names = FALSE)

## we need to fill in any NA meso_id's with the nearest non-NA pixel_id's fao_id

meso_lookup_id <- meso_lookup_id %>%
  arrange(pixel_id)

# Fill missing fao_id using nearest non-NA values. we will just use filling up or down for this, since we already know the pixel_ids are in order from where they are located. we assume that if the pixel id is close to it, then it will be in the same FAO id. 
library(zoo)
meso_lookup_id <- meso_lookup_id %>%
  mutate(meso_id = na.locf(meso_id, na.rm = FALSE, fromLast = FALSE)) %>%  # Forward fill
  mutate(meso_id = na.locf(meso_id, na.rm = FALSE, fromLast = TRUE))       # Backward fill

# Check if there are still any NAs left
sum(is.na(meso_lookup_id$meso_id)) 

write.csv(meso_lookup_id, here("data/model_features/mesopelagiczones/mesopelagiczones_fixed.csv"), row.names = FALSE)


  check <-   read.csv(here("data/model_features/mesopelagiczones/mesopelagiczones_fixed.csv"))

```

# Determine what ocean each cell is in
Flanders Marine Institute. Global Oceans and Seas, version 1. (2021). https://www.marineregions.org/. https://doi.org/10.14284/542. Accessed 27 July 2025.

Download from: https://doi.org/10.14284/542

```{r}

ocean_1 <- read.csv(here("data/model_features/deg_1_x_1/oceans.csv"))
sort(unique(ocean_1$ocean))
#  [1] ""                                         "Arctic Ocean"                             "Baltic Sea"                              
#  [4] "Indian Ocean"                             "Mediterranean Region"                     "North Atlantic Ocean"                    
#  [7] "North Pacific Ocean"                      "South Atlantic Ocean"                     "South China and Easter Archipelagic Seas"
# [10] "South Pacific Ocean"                      "Southern Ocean"


ocean_raw <- st_read(file.path(rdsi_raw_dir, "marine_regions/GOaS_v1_20211214"))

ocean_raw_test <- ocean_raw %>%
  st_drop_geometry()
# ok cool, we just need to apply the same method as we did for FAO/meso regions

# Convert grid to raster
grid <- data_grid %>%
  st_drop_geometry() %>%
  dplyr::select(lon, lat, pixel_id) %>% 
  rast(., type = "xyz") 

# Rasterize FAO areas
ocean_rast <- terra::rasterize(ocean_raw, grid, field = "name")
# ocean_rast <- rast(fasterize::fasterize(ocean_raw, raster(grid), field = "name"))
plot(ocean_rast)

# Count NA cells in FAO raster
na_count <- global(is.na(ocean_rast), "sum")
cat("\nNumber of NA cells in FAO raster:", na_count$sum, "\n") # 80287

351*720 - 80287 # 172719; ok, this value SHOULD BE ~180k (the number of ocean cells, e.g. grid). However, it is lower than that. So we are missing ~8000 cells that should have ocean information. 

writeRaster(ocean_rast, here("data/model_features/ocean/ocean_rast.tif"), overwrite = TRUE)

# Create lookup table
ocean_lookup <- ocean_rast %>%
  as.data.frame(xy = TRUE, na.rm = FALSE)

# Join with data_grid to get pixel_id and fao_id pairs
ocean_lookup_fin <- ocean_lookup %>%
  dplyr::select(lon = x, lat = y, ocean = name) %>%
  full_join(data_grid %>% st_drop_geometry(), by = c("lon", "lat")) %>% 
  filter(!is.na(pixel_id)) %>%
  dplyr::select(pixel_id, ocean)

write.csv(ocean_lookup_fin, here("data/model_features/ocean/ocean.csv"), row.names = FALSE)

# Analyze missing FAO IDs
missing_ocean <- ocean_lookup_fin %>%
  filter(is.na(ocean))

cat("\nNumber of pixels with missing ocean ID:", nrow(missing_ocean), "\n") # 8189

# Get the coordinates of missing pixels
missing_pixels <- data_grid %>%
  filter(pixel_id %in% missing_ocean$pixel_id)

# Save missing pixels for visualization
st_write(missing_pixels, here("data/model_features/ocean/missing_ocean_pixels.shp"), delete_layer = TRUE)

# Create a simple plot of missing pixels
missing_coords <- missing_pixels %>%
  st_centroid() %>%
  st_coordinates() %>%
  as.data.frame()

# Save coordinates for plotting
write.csv(missing_coords, here("data/model_features/ocean/missing_ocean_coords.csv"), row.names = FALSE)

## we need to fill in any NA fao_id's with the nearest non-NA pixel_id's fao_id
library(zoo)
ocean_lookup_fin <- ocean_lookup_fin %>%
  arrange(pixel_id)

# Fill missing fao_id using nearest non-NA values. we will just use filling up or down for this, since we already know the pixel_ids are in order from where they are located. we assume that if the pixel id is close to it, then it will be in the same FAO id. Nearest neighbor would be better probably. 
ocean_lookup_fin <- ocean_lookup_fin %>%
  mutate(ocean = na.locf(ocean, na.rm = FALSE, fromLast = FALSE)) %>%  # Forward fill
  mutate(ocean = na.locf(ocean, na.rm = FALSE, fromLast = TRUE))       # Backward fill

# Check if there are still any NAs left
sum(is.na(ocean_lookup_fin$ocean))  # 0 

write.csv(ocean_lookup_fin, here("data/model_features/ocean/ocean_fixed.csv"), row.names = FALSE)


  check <-   read.csv(here("data/model_features/ocean/ocean_fixed.csv"))

```


Distance to seamount data 
 
 - [Yesson et al. 2020](https://doi.pangaea.de/10.1594/PANGAEA.921688)

```{r}
library(nngeo)

pixel_size <- 0.5

mollweide_projection <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"

# Read in data_grid, generated in data_wrangling.Rmd
# We will do spatial joining in Mollweide, for proper calculations
# Note that data grid still retains lat and lon columns, for joining with non-spatial tibbles
# For Mollweide, always wrap around dateline, then transform, then calculate areas at end
data_grid <- data.table::fread(here("data/model_features/global_grid.csv"))%>%
  st_as_sf(wkt = "geometry_wkt",
           crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")%>% 
  st_wrap_dateline(options = c("WRAPDATELINE=YES", "DATELINEOFFSET=180"), quiet = TRUE) %>% 
  st_transform(mollweide_projection) %>%
  mutate(pixel_area_m2 = st_area(geometry_wkt)%>%
           units::drop_units()) 

seamounts <- st_read(file.path(rdsi_raw_dir, "seamounts-yesson-2019/"), layer = "YessonEtAl2019-Seamounts-V2")

analysis_projection = mollweide_projection

global_grid = data_grid

# Wrangle seamounts data
# Calculate nearest distance from the centroid of each pixel to each seamount

  seamounts <- seamounts %>%
    dplyr::select(seamount_id = PeakID,
                  geometry)%>% 
    st_wrap_dateline(options = c("WRAPDATELINE=YES", "DATELINEOFFSET=180"), quiet = TRUE) %>% 
    st_transform(analysis_projection)
  
  wrangle_seamounts <- nngeo::st_nn(global_grid %>%
                 st_centroid(),
               seamounts, 
               # Only select single nearest eez
               k = 1, 
               returnDist = T,
               parallel = 1) %>%# floor(parallel::detectCores()/4))  %>% 
    as_tibble() %>% 
    mutate(nearest_seamount_id =  seamounts$seamount_id[as.numeric(nn)], 
           nearest_seamount_distance_m = as.numeric(dist)) %>%
    dplyr::select(-nn,-dist) %>%
    bind_cols(global_grid %>%
                st_set_geometry(NULL) %>%
                dplyr::select(pixel_id))

  write.csv(wrangle_seamounts, here("data/model_features/seamounts.csv"), row.names = FALSE)
  
  check <-  read.csv(here("data/model_features/seamounts.csv"))

```


Make sure days at sea csv from Rousseau et al. is same resolution/projection as ours: https://data.imas.utas.edu.au/attachments/1241a51d-c8c2-4432-aa68-3d2bae142794/ConversionFishingHours.csv

 - we will use this to convert days at sea to hours, after modeling the number of vessels in each cell. 

```{r}

conversion_0.5 <- read.csv("https://data.imas.utas.edu.au/attachments/1241a51d-c8c2-4432-aa68-3d2bae142794/ConversionFishingHours.csv") %>%
  clean_names() %>%
    dplyr::select(lon, lat, mean, length_category)

data_grid_rast <- data_grid %>%
  st_drop_geometry() %>% 
  dplyr::select(lon, lat) %>%
  rast(., type = "xyz", crs = analysis_projection)
  

conversion_1_df <- data.frame(x = NA, y = NA, mean = NA, length_category = NA)

for(l in unique(conversion_0.5$length_category)){
  
  # l = "Over 50m"
  
  conversion_l <- conversion_0.5 %>%
    filter(length_category == l) %>%
    dplyr::select(-length_category) %>%
    rast(.) %>%
    resample(., data_grid_rast, method = "bilinear") %>%
    as.data.frame(., xy = TRUE) %>%
    mutate(length_category = l)
  
  conversion_1_df <- rbind(conversion_1_df, conversion_l)
  
}

conversion_1_df <- conversion_1_df %>%
  filter(!is.na(x))
# %>%
  #left_join(data_grid, by = c("x" = "lon", "y" = "lat"))

qs::qsave(conversion_1_df, here("data/int/hours_to_days_conversion_0.5.qs"))

 check <- qs::qread(here("data/int/hours_to_days_conversion_0.5.qs"))


```


